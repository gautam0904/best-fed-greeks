{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular v<unknown>\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview\n * @suppress {globalThis,undefinedVars}\n */\nfunction patchError(Zone) {\n  Zone.__load_patch('Error', (global, Zone, api) => {\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    const zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n    const NativeError = global[api.symbol('Error')] = global['Error'];\n    // Store the frames which should be removed from the stack frames\n    const zoneJsInternalStackFrames = {};\n    // We must find the frame where Error was created, otherwise we assume we don't understand stack\n    let zoneAwareFrame1;\n    let zoneAwareFrame2;\n    let zoneAwareFrame1WithoutNew;\n    let zoneAwareFrame2WithoutNew;\n    let zoneAwareFrame3WithoutNew;\n    global['Error'] = ZoneAwareError;\n    const stackRewrite = 'stackRewrite';\n    const zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n    function buildZoneFrameNames(zoneFrame) {\n      let zoneFrameName = {\n        zoneName: zoneFrame.zone.name\n      };\n      let result = zoneFrameName;\n      while (zoneFrame.parent) {\n        zoneFrame = zoneFrame.parent;\n        const parentZoneFrameName = {\n          zoneName: zoneFrame.zone.name\n        };\n        zoneFrameName.parent = parentZoneFrameName;\n        zoneFrameName = parentZoneFrameName;\n      }\n      return result;\n    }\n    function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame = true) {\n      let frames = originalStack.split('\\n');\n      let i = 0;\n      // Find the first frame\n      while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 || frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew || frames[i] === zoneAwareFrame3WithoutNew) && i < frames.length) {\n        i++;\n      }\n      for (; i < frames.length && zoneFrame; i++) {\n        let frame = frames[i];\n        if (frame.trim()) {\n          switch (zoneJsInternalStackFrames[frame]) {\n            case 0 /* FrameType.zoneJsInternal */:\n              frames.splice(i, 1);\n              i--;\n              break;\n            case 1 /* FrameType.transition */:\n              if (zoneFrame.parent) {\n                // This is the special frame where zone changed. Print and process it accordingly\n                zoneFrame = zoneFrame.parent;\n              } else {\n                zoneFrame = null;\n              }\n              frames.splice(i, 1);\n              i--;\n              break;\n            default:\n              frames[i] += isZoneFrame ? ` [${zoneFrame.zone.name}]` : ` [${zoneFrame.zoneName}]`;\n          }\n        }\n      }\n      return frames.join('\\n');\n    }\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n    function ZoneAwareError() {\n      // We always have to return native error otherwise the browser console will not work.\n      let error = NativeError.apply(this, arguments);\n      // Save original stack trace\n      const originalStack = error['originalStack'] = error.stack;\n      // Process the stack trace and rewrite the frames.\n      if (ZoneAwareError[stackRewrite] && originalStack) {\n        let zoneFrame = api.currentZoneFrame();\n        if (zoneJsInternalStackFramesPolicy === 'lazy') {\n          // don't handle stack trace now\n          error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n        } else if (zoneJsInternalStackFramesPolicy === 'default') {\n          try {\n            error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n          } catch (e) {\n            // ignore as some browsers don't allow overriding of stack\n          }\n        }\n      }\n      if (this instanceof NativeError && this.constructor != NativeError) {\n        // We got called with a `new` operator AND we are subclass of ZoneAwareError\n        // in that case we have to copy all of our properties to `this`.\n        Object.keys(error).concat('stack', 'message', 'cause').forEach(key => {\n          const value = error[key];\n          if (value !== undefined) {\n            try {\n              this[key] = value;\n            } catch (e) {\n              // ignore the assignment in case it is a setter and it throws.\n            }\n          }\n        });\n        return this;\n      }\n      return error;\n    }\n    // Copy the prototype so that instanceof operator works as expected\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    const zoneAwareStackSymbol = api.symbol('zoneAwareStack');\n    // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n    if (zoneJsInternalStackFramesPolicy === 'lazy') {\n      Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n          if (!this[zoneAwareStackSymbol]) {\n            this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n          }\n          return this[zoneAwareStackSymbol];\n        },\n        set: function (newStack) {\n          this.originalStack = newStack;\n          this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n        }\n      });\n    }\n    // those properties need special handling\n    const specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];\n    // those properties of NativeError should be set to ZoneAwareError\n    const nativeErrorProperties = Object.keys(NativeError);\n    if (nativeErrorProperties) {\n      nativeErrorProperties.forEach(prop => {\n        if (specialPropertyNames.filter(sp => sp === prop).length === 0) {\n          Object.defineProperty(ZoneAwareError, prop, {\n            get: function () {\n              return NativeError[prop];\n            },\n            set: function (value) {\n              NativeError[prop] = value;\n            }\n          });\n        }\n      });\n    }\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n      // Extend default stack limit as we will be removing few frames.\n      NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n      // make sure that ZoneAwareError has the same property which forwards to NativeError.\n      Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n        get: function () {\n          return NativeError.stackTraceLimit;\n        },\n        set: function (value) {\n          return NativeError.stackTraceLimit = value;\n        }\n      });\n    }\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n      Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n        // add named function here because we need to remove this\n        // stack frame when prepareStackTrace below\n        value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n          NativeError.captureStackTrace(targetObject, constructorOpt);\n        }\n      });\n    }\n    const ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n      get: function () {\n        return NativeError.prepareStackTrace;\n      },\n      set: function (value) {\n        if (!value || typeof value !== 'function') {\n          return NativeError.prepareStackTrace = value;\n        }\n        return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n          // remove additional stack information from ZoneAwareError.captureStackTrace\n          if (structuredStackTrace) {\n            for (let i = 0; i < structuredStackTrace.length; i++) {\n              const st = structuredStackTrace[i];\n              // remove the first function which name is zoneCaptureStackTrace\n              if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                structuredStackTrace.splice(i, 1);\n                break;\n              }\n            }\n          }\n          return value.call(this, error, structuredStackTrace);\n        };\n      }\n    });\n    if (zoneJsInternalStackFramesPolicy === 'disable') {\n      // don't need to run detectZone to populate zoneJs internal stack frames\n      return;\n    }\n    // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n    // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n    let detectZone = Zone.current.fork({\n      name: 'detect',\n      onHandleError: function (parentZD, current, target, error) {\n        if (error.originalStack && Error === ZoneAwareError) {\n          let frames = error.originalStack.split(/\\n/);\n          let runFrame = false,\n            runGuardedFrame = false,\n            runTaskFrame = false;\n          while (frames.length) {\n            let frame = frames.shift();\n            // On safari it is possible to have stack frame with no line number.\n            // This check makes sure that we don't filter frames on name only (must have\n            // line number or exact equals to `ZoneAwareError`)\n            if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n              // Get rid of the path so that we don't accidentally find function name in path.\n              // In chrome the separator is `(` and `@` in FF and safari\n              // Chrome: at Zone.run (zone.js:100)\n              // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n              // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n              // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n              let fnName = frame.split('(')[0].split('@')[0];\n              let frameType = 1 /* FrameType.transition */;\n              if (fnName.indexOf('ZoneAwareError') !== -1) {\n                if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                  zoneAwareFrame1 = frame;\n                  zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                } else {\n                  zoneAwareFrame1WithoutNew = frame;\n                  zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n                  if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                    zoneAwareFrame3WithoutNew = frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                  }\n                }\n                zoneJsInternalStackFrames[zoneAwareFrame2] = 0 /* FrameType.zoneJsInternal */;\n              }\n              if (fnName.indexOf('runGuarded') !== -1) {\n                runGuardedFrame = true;\n              } else if (fnName.indexOf('runTask') !== -1) {\n                runTaskFrame = true;\n              } else if (fnName.indexOf('run') !== -1) {\n                runFrame = true;\n              } else {\n                frameType = 0 /* FrameType.zoneJsInternal */;\n              }\n              zoneJsInternalStackFrames[frame] = frameType;\n              // Once we find all of the frames we can stop looking.\n              if (runFrame && runGuardedFrame && runTaskFrame) {\n                ZoneAwareError[stackRewrite] = true;\n                break;\n              }\n            }\n          }\n        }\n        return false;\n      }\n    });\n    // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and marked as an internal zoneJs frame.\n    const childDetectZone = detectZone.fork({\n      name: 'child',\n      onScheduleTask: function (delegate, curr, target, task) {\n        return delegate.scheduleTask(target, task);\n      },\n      onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      },\n      onCancelTask: function (delegate, curr, target, task) {\n        return delegate.cancelTask(target, task);\n      },\n      onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      }\n    });\n    // we need to detect all zone related frames, it will\n    // exceed default stackTraceLimit, so we set it to\n    // larger number here, and restore it after detect finish.\n    // We cast through any so we don't need to depend on nodejs typings.\n    const originalStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 100;\n    // we schedule event/micro/macro task, and invoke them\n    // when onSchedule, so we can get all stack traces for\n    // all kinds of tasks with one error thrown.\n    childDetectZone.run(() => {\n      childDetectZone.runGuarded(() => {\n        const fakeTransitionTo = () => {};\n        childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, () => {\n          childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, () => {\n            childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n              throw new Error();\n            }, undefined, t => {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n            childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n              throw Error();\n            }, undefined, t => {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n          }, undefined, t => {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          }, () => {});\n        }, undefined, t => {\n          t._transitionTo = fakeTransitionTo;\n          t.invoke();\n        }, () => {});\n      });\n    });\n    Error.stackTraceLimit = originalStackTraceLimit;\n  });\n}\npatchError(Zone);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}