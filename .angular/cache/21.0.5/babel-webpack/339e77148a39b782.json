{"ast":null,"code":"import _asyncToGenerator from \"/Users/malaviyagautam/Code/JS/MEAN/Ionic/ionic-project-master/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport { HttpHeaders } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { ToastController } from '@ionic/angular';\nimport { Observable, AsyncSubject } from \"rxjs\";\nimport { tap, mergeMap } from \"rxjs/operators\";\nimport { MessageService } from '../services/common/message.service';\nimport { BFGUserService } from '../services/bfg-user.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic/angular\";\nimport * as i2 from \"../services/bfg-user.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"../services/common/message.service\";\nexport let CustomHttpInterceptor = /*#__PURE__*/(() => {\n  class CustomHttpInterceptor {\n    toast;\n    bfgUser;\n    router;\n    msg;\n    _justRefreshed = false;\n    constructor(toast, bfgUser, router, msg) {\n      this.toast = toast;\n      this.bfgUser = bfgUser;\n      this.router = router;\n      this.msg = msg;\n    }\n    intercept(request, next) {\n      return this.handleAccess(request, next);\n    }\n    handleAccess(request, next) {\n      var _this = this;\n      return this.bfgUser.fetchUser().pipe(mergeMap(user => {\n        let changedRequest = this.getTokenRequest(user, request),\n          hasToken = user && user.access_token,\n          refreshTried = false,\n          isRefresh = changedRequest.url.indexOf('refresh-token') != -1;\n        if (isRefresh) {\n          this._justRefreshed = true;\n        }\n        const subject = new AsyncSubject();\n        next.handle(changedRequest).pipe(tap(/*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (evt) {\n            _this.handleSuccess(evt, subject, isRefresh);\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(), /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (err) {\n            yield _this.handleError(changedRequest, next, subject, user, err);\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }())).subscribe();\n        return subject;\n      }));\n    }\n    handleSuccess(evt, subject, isRefresh = false) {\n      if (!(evt instanceof HttpResponse)) {\n        return;\n      }\n      if (evt.body && evt.body.success) {}\n      if (evt.body) {\n        evt.body.error = false;\n      }\n      if (evt.headers.has('Authorization')) {\n        let authHeader = evt.headers.get('Authorization'),\n          authToken = authHeader.replace('Bearer', '').trim();\n        this.bfgUser.setTokenFromResponse(authToken);\n        this.bfgUser.fetchUserConfig().subscribe();\n      }\n      if (!isRefresh) {\n        this._justRefreshed = false;\n      }\n      subject.next(evt);\n      subject.complete();\n    }\n    handleError(_x3, _x4, _x5, _x6, _x7) {\n      var _this2 = this;\n      return _asyncToGenerator(function* (request, next, subject, user, err, refresh = false) {\n        if (!(err instanceof HttpErrorResponse)) {\n          return Promise.resolve();\n        }\n        let hasToken = user && user.access_token;\n        console.log('hasToken', hasToken);\n        const errorEvent = new HttpResponse({\n            body: {\n              error: true,\n              message: err.error.message,\n              status: err.status,\n              statusText: err.statusText\n            }\n          }),\n          isLogin = request.url.indexOf('auth/login') != -1,\n          isRefresh = request.url.indexOf('auth/refresh-token') != -1,\n          isRegister = request.url.indexOf('auth/register') != -1,\n          isForgotPassword = request.url.indexOf('auth/forgot-password') != -1;\n        console.log('HttpErrorResponse', err);\n        let header = isLogin ? 'Unable To Login' : 'Authentication Error',\n          message = '',\n          authenticationError = false,\n          serverError = false;\n        switch (err.status) {\n          case 403:\n          case 401:\n            authenticationError = true;\n            message = isLogin ? 'Please make sure you have entered your login/password correctly.' : 'Access not verified, please try logging in.';\n            if (err && err.error && typeof err.error.error == 'string' && err.error.error == 'user_inactive') {\n              message = 'Please make sure you have activated your account.';\n            }\n            break;\n          case 422:\n            authenticationError = true;\n            let errors = err.error && err.error.errors ? err.error.errors : {};\n            let messages = [].concat(errors.login ? errors.login : [], errors.password ? errors.password : []);\n            message = messages.length > 0 ? '<ul><li>' + messages.join('</li><li>') + '</li></ul>' : 'Make sure you have registered and successfully activated your account';\n            break;\n          case 500:\n            serverError = true;\n            break;\n          default:\n            header = 'Unknown Error';\n            message = 'Unable to complete request. Please contact support if this continues.';\n            break;\n        }\n        let needMessage = false,\n          redirectToLogin = false;\n        if (isRefresh && (authenticationError || serverError)) {\n          needMessage = true;\n          redirectToLogin = true;\n          message = \"Could not authenticate. Please try logging in again\";\n          _this2.bfgUser.clearStoredUser();\n          _this2.msg.hideLoader();\n        } else if ((isLogin || isForgotPassword) && authenticationError) {\n          needMessage = true;\n        } else if (isRegister && authenticationError) {\n          let errors = err.error && err.error.errors ? err.error.errors : {};\n          let messages = [].concat(errors.login ? errors.login : [], errors.password ? errors.password : [], errors.email ? errors.email : []);\n          errorEvent.body.message = messages.length > 0 ? '<ul><li>' + messages.join('</li><li>') + '</li></ul>' : 'Make sure you have correctly filled out each field to register successfully.';\n        } else if (authenticationError && hasToken && !refresh && !_this2._justRefreshed) {\n          // Try to get refreshToken and replay our original request.\n          // Has to be a simpler less nested way of doing this.\n          // Will investigate later.\n          const refreshToken = _this2.bfgUser.refreshToken;\n          if (refreshToken) {\n            // For now, just redirect to login since refresh token logic is complex\n            _this2.bfgUser.clearStoredUser();\n            _this2.router.navigateByUrl('login');\n          } else {\n            redirectToLogin = true;\n          }\n        } else if (authenticationError) {\n          redirectToLogin = refresh || _this2._justRefreshed || !hasToken ? true : false;\n        }\n        // Either way, if error it means refresh failed or the original request failed. So just reset.\n        _this2._justRefreshed = false;\n        if (needMessage) {\n          let toast = yield _this2.toast.create({\n            header: header,\n            message: message,\n            position: 'bottom',\n            duration: 5000,\n            buttons: [{\n              text: 'Close',\n              role: 'cancel'\n            }]\n          });\n          yield toast.present();\n        }\n        //log error \n        subject.next(errorEvent);\n        subject.complete();\n        if (redirectToLogin) {\n          _this2.bfgUser.clearStoredUser();\n          _this2.router.navigateByUrl('login');\n        }\n        return Promise.resolve();\n      }).apply(this, arguments);\n    }\n    getTokenRequest(user, request, refreshed = false) {\n      const headerSettings = {};\n      for (const key of request.headers.keys()) {\n        headerSettings[key] = request.headers.getAll(key);\n      }\n      if (user && user.access_token) {\n        headerSettings['Authorization'] = 'Bearer ' + user.access_token;\n      }\n      headerSettings['Content-Type'] = 'application/json';\n      const newHeader = new HttpHeaders(headerSettings);\n      return request.clone({\n        headers: newHeader\n      });\n    }\n    static ɵfac = function CustomHttpInterceptor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CustomHttpInterceptor)(i0.ɵɵinject(i1.ToastController), i0.ɵɵinject(i2.BFGUserService), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.MessageService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: CustomHttpInterceptor,\n      factory: CustomHttpInterceptor.ɵfac\n    });\n  }\n  return CustomHttpInterceptor;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}