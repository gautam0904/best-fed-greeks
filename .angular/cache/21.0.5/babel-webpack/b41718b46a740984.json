{"ast":null,"code":"import { Injectable, EventEmitter, Directive, ElementRef, NgZone, Input, Output, HostListener, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass WindowRef {\n  /**\n   * @return {?}\n   */\n  get nativeWindow() {\n    return window;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst MAX_LOOKUP_RETRIES = 3;\nclass AutosizeDirective {\n  /**\n   * @param {?} element\n   * @param {?} _window\n   * @param {?} _zone\n   */\n  constructor(element, _window, _zone) {\n    this.element = element;\n    this._window = _window;\n    this._zone = _zone;\n    this.onlyGrow = false;\n    this.useImportant = false;\n    this.resized = new EventEmitter();\n    this.autosize = true;\n    this.retries = 0;\n    this._destroyed = false;\n    if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n      this._findNestedTextArea();\n    } else {\n      this.textAreaEl = this.element.nativeElement;\n      this.textAreaEl.style['overflow-y'] = 'hidden';\n      this._onTextAreaFound();\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set minRows(value) {\n    this._minRows = value;\n    if (this.textAreaEl) {\n      this.textAreaEl.rows = value;\n    }\n  }\n  /**\n   * @param {?} autosize\n   * @return {?}\n   */\n  set _autosize(autosize) {\n    this.autosize = typeof autosize === 'boolean' ? autosize : true;\n  }\n  /**\n   * @param {?} textArea\n   * @return {?}\n   */\n  onInput(textArea) {\n    this.adjust();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._destroyed = true;\n    if (this._windowResizeHandler) {\n      this._window.nativeWindow.removeEventListener('resize', this._windowResizeHandler, false);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentChecked() {\n    this.adjust();\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    this.adjust(true);\n  }\n  /**\n   * @return {?}\n   */\n  _findNestedTextArea() {\n    this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n    if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n      this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n    }\n    if (!this.textAreaEl) {\n      if (this.retries >= MAX_LOOKUP_RETRIES) {\n        console.warn('ngx-autosize: textarea not found');\n      } else {\n        this.retries++;\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        () => {\n          this._findNestedTextArea();\n        }, 100);\n      }\n      return;\n    }\n    this.textAreaEl.style['overflow-y'] = 'hidden';\n    this._onTextAreaFound();\n  }\n  /**\n   * @return {?}\n   */\n  _onTextAreaFound() {\n    this._addWindowResizeHandler();\n    setTimeout(\n    /**\n    * @return {?}\n    */\n    () => {\n      this.adjust();\n    });\n  }\n  /**\n   * @return {?}\n   */\n  _addWindowResizeHandler() {\n    this._windowResizeHandler = Debounce(\n    /**\n    * @return {?}\n    */\n    () => {\n      this._zone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.adjust();\n      });\n    }, 200);\n    this._zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => {\n      this._window.nativeWindow.addEventListener('resize', this._windowResizeHandler, false);\n    });\n  }\n  /**\n   * @param {?=} inputsChanged\n   * @return {?}\n   */\n  adjust(inputsChanged = false) {\n    if (this.autosize && !this._destroyed && this.textAreaEl && this.textAreaEl.parentNode) {\n      /** @type {?} */\n      const currentText = this.textAreaEl.value;\n      if (inputsChanged === false && currentText === this._oldContent && this.textAreaEl.offsetWidth === this._oldWidth) {\n        return;\n      }\n      this._oldContent = currentText;\n      this._oldWidth = this.textAreaEl.offsetWidth;\n      /** @type {?} */\n      const clone = this.textAreaEl.cloneNode(true);\n      /** @type {?} */\n      const parent = this.textAreaEl.parentNode;\n      clone.style.width = this.textAreaEl.offsetWidth + 'px';\n      clone.style.visibility = 'hidden';\n      clone.style.position = 'absolute';\n      clone.textContent = currentText;\n      parent.appendChild(clone);\n      clone.style['overflow-y'] = 'hidden';\n      clone.style.height = 'auto';\n      /** @type {?} */\n      let height = clone.scrollHeight;\n      // add into height top and bottom borders' width\n      /** @type {?} */\n      let computedStyle = this._window.nativeWindow.getComputedStyle(clone, null);\n      height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n      height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n      // add into height top and bottom paddings width\n      height += parseInt(computedStyle.getPropertyValue('padding-top'));\n      height += parseInt(computedStyle.getPropertyValue('padding-bottom'));\n      /** @type {?} */\n      const oldHeight = this.textAreaEl.offsetHeight;\n      /** @type {?} */\n      const willGrow = height > oldHeight;\n      if (this.onlyGrow === false || willGrow) {\n        /** @type {?} */\n        const lineHeight = this._getLineHeight();\n        /** @type {?} */\n        const rowsCount = height / lineHeight;\n        if (this._minRows && this._minRows >= rowsCount) {\n          height = this._minRows * lineHeight;\n        } else if (this.maxRows && this.maxRows <= rowsCount) {\n          // never shrink the textarea if onlyGrow is true\n          /** @type {?} */\n          const maxHeight = this.maxRows * lineHeight;\n          height = this.onlyGrow ? Math.max(maxHeight, oldHeight) : maxHeight;\n          this.textAreaEl.style['overflow-y'] = 'auto';\n        } else {\n          this.textAreaEl.style['overflow-y'] = 'hidden';\n        }\n        /** @type {?} */\n        const heightStyle = height + 'px';\n        /** @type {?} */\n        const important = this.useImportant ? 'important' : '';\n        this.textAreaEl.style.setProperty('height', heightStyle, important);\n        this.resized.emit(height);\n      }\n      parent.removeChild(clone);\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n  _getLineHeight() {\n    /** @type {?} */\n    let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n    if (isNaN(lineHeight) && this._window.nativeWindow.getComputedStyle) {\n      /** @type {?} */\n      const styles = this._window.nativeWindow.getComputedStyle(this.textAreaEl);\n      lineHeight = parseInt(styles.lineHeight, 10);\n    }\n    if (isNaN(lineHeight)) {\n      /** @type {?} */\n      const fontSize = this._window.nativeWindow.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n      lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n    }\n    return lineHeight;\n  }\n}\n\n/** @nocollapse */\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._minRows;\n  /** @type {?} */\n  AutosizeDirective.prototype.maxRows;\n  /** @type {?} */\n  AutosizeDirective.prototype.onlyGrow;\n  /** @type {?} */\n  AutosizeDirective.prototype.useImportant;\n  /** @type {?} */\n  AutosizeDirective.prototype.resized;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype.autosize;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype.retries;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype.textAreaEl;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._oldContent;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._oldWidth;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._windowResizeHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._destroyed;\n  /** @type {?} */\n  AutosizeDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._window;\n  /**\n   * @type {?}\n   * @private\n   */\n  AutosizeDirective.prototype._zone;\n  /* Skipping unhandled member: ;*/\n  /* Skipping unhandled member: ;*/\n}\n/**\n * @param {?} func\n * @param {?} wait\n * @param {?=} immediate\n * @return {?}\n */\nfunction Debounce(func, wait, immediate = false) {\n  /** @type {?} */\n  let timeout;\n  return (\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      const context = this;\n      /** @type {?} */\n      const args = arguments;\n      /** @type {?} */\n      const later =\n      /**\n      * @return {?}\n      */\n      function () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      };\n      /** @type {?} */\n      const callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) {\n        func.apply(context, args);\n      }\n    }\n  );\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AutosizeModule {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AutosizeDirective, AutosizeModule, WindowRef as Éµa };\n//# sourceMappingURL=ngx-autosize.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}